package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class usbcore001_hostc_template
{
  protected static String nl;
  public static synchronized usbcore001_hostc_template create(String lineSeparator)
  {
    nl = lineSeparator;
    usbcore001_hostc_template result = new usbcore001_hostc_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/* CODE_BLOCK_BEGIN[USBCORE001_host.c] */" + NL + "" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Dec 4, 2012                                            **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** CM          App Developer                                                  **" + NL + "*******************************************************************************/" + NL + "" + NL + "/* ==========================================================================" + NL + " *" + NL + " * Synopsys HS OTG Linux Software Driver and documentation (hereinafter," + NL + " * \"Software\") is an Unsupported proprietary work of Synopsys, Inc. unless" + NL + " * otherwise expressly agreed to in writing between Synopsys and you." + NL + " *" + NL + " * The Software IS NOT an item of Licensed Software or Licensed Product under" + NL + " * any End User Software License Agreement or Agreement for Licensed Product" + NL + " * with Synopsys or any supplement thereto. You are permitted to use and" + NL + " * redistribute this Software in source and binary forms, with or without" + NL + " * modification, provided that redistributions of source code must retain this" + NL + " * notice. You may not view, use, disclose, copy or distribute this file or" + NL + " * any information contained herein except pursuant to this license grant from" + NL + " * Synopsys. If you do not agree with this notice, including the disclaimer" + NL + " * below, then you are not authorized to use the Software." + NL + " *" + NL + " * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN \"AS IS\" BASIS" + NL + " * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE" + NL + " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE" + NL + " * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT," + NL + " * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES" + NL + " * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR" + NL + " * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER" + NL + " * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT" + NL + " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY" + NL + " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH" + NL + " * DAMAGE." + NL + " * ========================================================================== */" + NL + "" + NL + "/*" + NL + "  Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)" + NL + "" + NL + "  Permission to use, copy, modify, distribute, and sell this" + NL + "  software and its documentation for any purpose is hereby granted" + NL + "  without fee, provided that the above copyright notice appear in" + NL + "  all copies and that both that the copyright notice and this" + NL + "  permission notice and warranty disclaimer appear in supporting" + NL + "  documentation, and that the name of the author not be used in" + NL + "  advertising or publicity pertaining to distribution of the" + NL + "  software without specific, written prior permission." + NL + "" + NL + "  The author disclaim all warranties with regard to this" + NL + "  software, including all implied warranties of merchantability" + NL + "  and fitness.  In no event shall the author be liable for any" + NL + "  special, indirect or consequential damages or any damages" + NL + "  whatsoever resulting from loss of use, data or profits, whether" + NL + "  in an action of contract, negligence or other tortious action," + NL + "  arising out of or in connection with the use or performance of" + NL + "  this software." + NL + "*/" + NL + "" + NL + "/**" + NL + " * @file  usbcore001_host.c" + NL + " *" + NL + " * @brief This file contains implementations of all Public and Private functions" + NL + " *        of USB host glue logic." + NL + " *" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Include Files                                         **" + NL + "*******************************************************************************/" + NL + "#include <stdlib.h>" + NL + "#include <string.h>" + NL + "#include \"../../src/USBLD001/Type_CM.h\"" + NL + "#include \"../../src/USBLD001/dwc_common_port/usb.h\"" + NL + "#include \"../../inc/USBCore001/usbcore001_host.h\"" + NL + "#include \"../../src/USBLD001/driver/dwc_otg_hcd.h\"" + NL + "#include \"../../src/USBLD001/driver/dwc_otg_hcd_if.h\"" + NL + "" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup USBCORE001_host_privateparam" + NL + " * @{" + NL + " */" + NL + "" + NL + "#ifndef DWC_DEVICE_ONLY" + NL;
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = NL + NL + NL + "typedef struct USBCORE001_HostEndpoint" + NL + "{" + NL + "  usb_endpoint_descriptor_t Desc;" + NL + "  void *HcPriv;" + NL + "}USBCORE001_HostEndpoint;" + NL + "" + NL + "USBCORE001_HostEndpoint USBCORE001_HostEndpointpIn[USBCORE001_HOST_MAX_PIPE];" + NL + "" + NL + "/**" + NL + " * This contains the information of the Host Controller Driver." + NL + " */  " + NL + "typedef struct USBCORE001_HostControllerDriver" + NL + "{" + NL + "  USBCORE001_HostEndpoint *EndPoint[USBCORE001_HOST_MAX_PIPE];" + NL + "  USBCORE001_HostEvents *USB_HostEvents;" + NL + "  USBCORE001_HostConnectEventsCallBack* USB_ConEvent;" + NL + "  uint8_t CurPipeNum;" + NL + "  dwc_otg_hcd_t *GHCD;" + NL + "}USBCORE001_HostControllerDriver;" + NL + "" + NL + "USBCORE001_HostControllerDriver USBCORE001_HostHCD;" + NL + "" + NL + "struct dwc_otg_hcd_pipe_info USBCORE001_HostPipe[USBCORE001_HOST_MAX_PIPE] ;" + NL + "" + NL + "/* URB instance to queue all transfers */" + NL + "dwc_otg_hcd_urb_t USBCORE001_HostDwcOtgUrb;" + NL + "" + NL + "/* Instance of host controller driver */" + NL + "dwc_otg_hcd_t USBCORE001_HostDwcOtgHcd;" + NL + "" + NL + "/* Period for interrupt transfer */ " + NL + "uint8_t USBCORE001_HostInterruptInterval = 0;" + NL + "" + NL + "/* This flag indicates the completion of queued URB */" + NL + "volatile int USBCORE001_HostURBFlag;" + NL + "" + NL + "/* Data buffer to receive data */" + NL + "uint8_t USBCORE001_DataBuffer[USBCORE001_HOST_BULK_XFER];" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + " " + NL + " " + NL + "/**" + NL + " * @ingroup USBCORE001_privatefunc" + NL + " * @{" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Private Function declarations                              **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @brief This callback will notify device disconnected from synopsys driver and " + NL + " * will notify same to the LUFA." + NL + " * @param[in]   hcd Pointer to dwc_otg_hcd_t structure" + NL + " * @return int" + NL + " */" + NL + "static int USBCORE001_HostHCDDisconnect(dwc_otg_hcd_t * HCDPtr);" + NL + "" + NL + "/**" + NL + " * @brief Dummy callback to make it compatible with synopsys driver." + NL + " * @param[in]   hcd Pointer to dwc_otg_hcd_t structure" + NL + " * @return int" + NL + " */" + NL + "static int USBCORE001_HostHCDStart(dwc_otg_hcd_t * HCDPtr);" + NL + "" + NL + "/**" + NL + " * @brief Dummy callback to make it compatible with synopsys driver." + NL + " * @param[in]   hcd Pointer to dwc_otg_hcd_t structure" + NL + " * @return int" + NL + " */" + NL + "static int USBCORE001_HostHCDHubInfo(dwc_otg_hcd_t * HCDPtr," + NL + "      void *URBHandlePtr, uint32_t * HubAddrPtr,uint32_t * PortAddrPtr);" + NL + "" + NL + "/**" + NL + " * @brief Dummy callback to make it compatible with synopsys driver." + NL + " * @param[in]   hcd Pointer to dwc_otg_hcd_t structure" + NL + " * @return int" + NL + " */" + NL + "static int USBCORE001_HostHCDSpeed(dwc_otg_hcd_t * HCDPtr, void *URBHandlePtr);" + NL + "" + NL + "/**" + NL + " * @brief Dummy callback to make it compatible with synopsys driver." + NL + " * @param[in]   hcd Pointer to dwc_otg_hcd_t structure" + NL + " * @return int" + NL + " */" + NL + "static int USBCORE001_HostHCDGetBHNPEnable(dwc_otg_hcd_t * HCDPtr);" + NL + "" + NL + "/**" + NL + " * @brief This call back will be called on completion of queued URB." + NL + " * @param[in]   hcd Pointer to dwc_otg_hcd_t structure" + NL + " * @urb_handle[in]  pointer to dummy urb handle" + NL + " * @dwc_otg_urb[in] pointer to dwc_otg_hcd_urb_t structure" + NL + " * @status[in]    Indicates the completion status of URB" + NL + " * @return int" + NL + " */" + NL + "static int USBCORE001_HostHCDComplete(dwc_otg_hcd_t * HCDPtr," + NL + "    void *URBHandlePtr, dwc_otg_hcd_urb_t * DwcOtgUrbPtr, int32_t Status);" + NL + "" + NL + "/**" + NL + " * @brief This callback will notify device connected from synopsys driver and " + NL + " * will notify same to the LUFA." + NL + " * @param[in]   " + NL + " * @return int" + NL + " */" + NL + "static int USBCORE001_HostHCDConnect(void);" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/** Host controller driver operation callback function structure */ " + NL + "static struct dwc_otg_hcd_function_ops USBCORE001_HostHCDfops = {" + NL + "  USBCORE001_HostHCDStart," + NL + "  USBCORE001_HostHCDDisconnect," + NL + "  USBCORE001_HostHCDHubInfo," + NL + "  USBCORE001_HostHCDSpeed," + NL + "  USBCORE001_HostHCDComplete," + NL + "  USBCORE001_HostHCDGetBHNPEnable," + NL + "  USBCORE001_HostHCDConnect" + NL + "};" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                     Private Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "static int USBCORE001_HostHCDDisconnect(dwc_otg_hcd_t * HCDPtr)" + NL + "{" + NL + "  uint8_t PIPECnt;" + NL + "  " + NL + "  for(PIPECnt = 0; PIPECnt < USBCORE001_HOST_MAX_PIPE; PIPECnt++ )" + NL + "  {" + NL + "    if(USBCORE001_HostHCD.EndPoint[PIPECnt] != NULL)" + NL + "      if(USBCORE001_HostHCD.EndPoint[PIPECnt]->HcPriv)" + NL + "        USBCORE001_HostHCD.EndPoint[PIPECnt]->HcPriv = NULL;" + NL + "  }" + NL + "    " + NL + "  if(NULL != USBCORE001_HostHCD.USB_ConEvent->USBCORE001_HostDisconnect)" + NL + "  {" + NL + "    USBCORE001_HostHCD.USB_ConEvent->USBCORE001_HostDisconnect();" + NL + "  }  " + NL + "" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "" + NL + "static int USBCORE001_HostHCDStart(dwc_otg_hcd_t * HCDPtr)" + NL + "{" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "" + NL + "static int USBCORE001_HostHCDHubInfo(dwc_otg_hcd_t * HCDPtr," + NL + "      void *URBHandlePtr, uint32_t * HubAddrPtr,uint32_t * PortAddrPtr)" + NL + "{" + NL + "  *HubAddrPtr = 0;" + NL + "  *PortAddrPtr = 0;" + NL + "" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "" + NL + "static int USBCORE001_HostHCDSpeed(dwc_otg_hcd_t * HCDPtr, void *URBHandlePtr)" + NL + "{" + NL + "  hprt0_data_t * HPrtPtr;" + NL + "" + NL + "  HPrtPtr = (hprt0_data_t *)HCDPtr->core_if->host_if->hprt0;" + NL + "" + NL + "  if(HPrtPtr->b.prtspd & 1)" + NL + "    return USB_SPEED_FULL;" + NL + "  else" + NL + "    return USB_SPEED_LOW;" + NL + "}" + NL + "" + NL + "" + NL + "static int USBCORE001_HostHCDGetBHNPEnable(dwc_otg_hcd_t * HCDPtr)" + NL + "{" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "" + NL + "static int USBCORE001_HostHCDComplete(dwc_otg_hcd_t * HCDPtr," + NL + "    void *URBHandlePtr, dwc_otg_hcd_urb_t * DwcOtgUrbPtr, int32_t Status)" + NL + "{" + NL + "  " + NL + "  if(DwcOtgUrbPtr->status == 0)" + NL + "  { " + NL + "    USBCORE001_HostURBFlag = 1;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    USBCORE001_HostURBFlag = DwcOtgUrbPtr->status;" + NL + "  }" + NL + "" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "" + NL + "static int USBCORE001_HostHCDConnect(void)" + NL + "{" + NL + "  if(NULL != USBCORE001_HostHCD.USB_ConEvent->USBCORE001_HostConnect)" + NL + "  {" + NL + "    USBCORE001_HostHCD.USB_ConEvent->USBCORE001_HostConnect();" + NL + "  }  " + NL + "" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                     Public Function Definitions                            **" + NL + "*******************************************************************************/" + NL + "/* This function registers the call back for USB host status events  */" + NL + "void USBCORE001_HostCallBackRegister(USBCORE001_HostEvents *USBH_Events)" + NL + "{" + NL + "  if(NULL != USBH_Events)" + NL + "  {" + NL + "    USBCORE001_HostHCD.USB_HostEvents = USBH_Events;" + NL + "  }" + NL + "}" + NL + "" + NL + "/* This function registers call back for USB connect and disconnect events*/" + NL + "void USBCORE001_ConnectEventRegister" + NL + "                            (USBCORE001_HostConnectEventsCallBack *USB_ConEvent)" + NL + "{" + NL + "  if(NULL != USB_ConEvent)" + NL + "  {\t" + NL + "    USBCORE001_HostHCD.USB_ConEvent = USB_ConEvent;" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "/* This function initialises the synopsys host controller driver. */" + NL + "int USBCORE001_HostStart(USBCORE001_OtgDevice *OtgDevPtr)" + NL + "{" + NL + "  int RetVal = 0;" + NL + "" + NL + "  if(dwc_otg_hcd_init(&USBCORE001_HostDwcOtgHcd, OtgDevPtr->CoreIfPtr))" + NL + "  {" + NL + "    RetVal = -DWC_E_NO_MEMORY;" + NL + "    goto end;" + NL + "  }" + NL + "" + NL + "  OtgDevPtr->HCDPtr = &USBCORE001_HostDwcOtgHcd;" + NL + "" + NL + "  if (dwc_otg_hcd_start(&USBCORE001_HostDwcOtgHcd, &USBCORE001_HostHCDfops)) {" + NL + "    return 0;" + NL + "  }" + NL + "" + NL + "end:" + NL + "  return RetVal;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function resets the USB host port.*/" + NL + "void Reset_Host(void)" + NL + "{" + NL + "  reset_tasklet_func(&USBCORE001_HostDwcOtgHcd);" + NL + "}" + NL + "" + NL + "/* This function gets the status of USB host port.*/" + NL + "uint8_t Get_HostStat(void)" + NL + "{" + NL + "  uint8_t HostStat = USBCORE001_HOST_STATE_WaitForDevice;" + NL + "  if(NULL != USBCORE001_HostHCD.USB_HostEvents->USBCORE001_HostStatGet)" + NL + "  {" + NL + "    USBCORE001_HostHCD.USB_HostEvents->USBCORE001_HostStatGet(&HostStat);" + NL + "  }" + NL + "  return(HostStat);" + NL + "}" + NL + "" + NL + "/* This function selects through which communication will happen." + NL + " * This is the LUFA compatible API." + NL + " */" + NL + "void Pipe_SelectPipe(const uint8_t PipeNumber)" + NL + "{" + NL + "  USBCORE001_HostRequestHeader Request;" + NL + "  uint8_t HostStat = USBCORE001_HOST_STATE_WaitForDevice;" + NL + "" + NL + "  if(NULL != USBCORE001_HostHCD.USB_HostEvents->USBCORE001_HostStatGet)" + NL + "  {" + NL + "    USBCORE001_HostHCD.USB_HostEvents->USBCORE001_HostStatGet(&HostStat);" + NL + "  }" + NL + "" + NL + "  if(PipeNumber == PIPE_CONTROLPIPE)" + NL + "  {" + NL + "    if(HostStat >= USBCORE001_HOST_STATE_Addressed)" + NL + "    {" + NL + "      USBCORE001_HostPipe[PIPE_CONTROLPIPE].dev_addr = USB_HOST_DEVICEADDRESS;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      USBCORE001_HostPipe[PIPE_CONTROLPIPE].dev_addr = 0;    " + NL + "    }" + NL + "" + NL + "    if(NULL != USBCORE001_HostHCD.USB_HostEvents->USBCORE001_HostCtrlRequestGet)" + NL + "    {" + NL + "      USBCORE001_HostHCD.USB_HostEvents->USBCORE001_HostCtrlRequestGet(&Request);" + NL + "    }" + NL + "    USBCORE001_HostPipe[PIPE_CONTROLPIPE].mps = ";
  protected final String TEXT_4 = ";" + NL + "    USBCORE001_HostPipe[PIPE_CONTROLPIPE].pipe_dir " + NL + "                                  = Request.bmRequestType & 0xFE;" + NL + "  }" + NL + "" + NL + "  memcpy(&USBCORE001_HostDwcOtgUrb.pipe_info, &USBCORE001_HostPipe[PipeNumber]," + NL + "                                        sizeof(struct dwc_otg_hcd_pipe_info));" + NL + "  USBCORE001_HostHCD.CurPipeNum = PipeNumber;" + NL + "}" + NL + "" + NL + "/* This function sends control request to the selected pipe." + NL + " * This is the LUFA compatible API." + NL + " */" + NL + "uint8_t USB_Host_SendControlRequest(void* const BufferPtr)" + NL + "{" + NL + "  uint8_t Status;" + NL + "  USBCORE001_HostRequestHeader Request;" + NL + "  " + NL + "  if(NULL != USBCORE001_HostHCD.USB_HostEvents->USBCORE001_HostCtrlRequestGet)" + NL + "  {" + NL + "    USBCORE001_HostHCD.USB_HostEvents->USBCORE001_HostCtrlRequestGet(&Request);" + NL + "  }  " + NL + "" + NL + "  dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL, BufferPtr," + NL + "   (int)BufferPtr, Request.wLength, &Request, (int)&Request, 1, 0);" + NL + "" + NL + "  USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum] = " + NL + "                     &USBCORE001_HostEndpointpIn[USBCORE001_HostHCD.CurPipeNum];" + NL + "" + NL + "  USBCORE001_HostURBFlag = 0;" + NL + "  if(dwc_otg_hcd_urb_enqueue(&USBCORE001_HostDwcOtgHcd, " + NL + "                             &USBCORE001_HostDwcOtgUrb, " + NL + "  &USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum]->HcPriv, 1) != 0)" + NL + "  {" + NL + "    return  HOST_SENDCONTROL_DeviceDisconnected;" + NL + "  }  " + NL + "" + NL + "  while(USBCORE001_HostURBFlag == 0);" + NL + "" + NL + "  memset(&USBCORE001_HostDwcOtgUrb, 0, sizeof(USBCORE001_HostDwcOtgUrb));" + NL + "" + NL + "  if(Get_HostStat() == USBCORE001_HOST_STATE_WaitForDevice)" + NL + "  {" + NL + "    Status = HOST_SENDCONTROL_DeviceDisconnected;" + NL + "  }" + NL + "  else if(USBCORE001_HostURBFlag != 1)" + NL + "  {" + NL + "    Status = HOST_SENDCONTROL_PipeError;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    Status = HOST_SENDCONTROL_Successful;" + NL + "  }" + NL + "" + NL + "  return(Status);" + NL + "}" + NL + "" + NL + "/* This function configures pipes as needed by LUFA." + NL + " * This is the LUFA compatible API." + NL + " */" + NL + "bool Pipe_ConfigurePipe(const uint8_t Number," + NL + "                        const uint8_t Type," + NL + "                        const uint8_t Token," + NL + "                        const uint8_t EndpointNumber," + NL + "                        const uint16_t Size," + NL + "                        const uint8_t Banks)" + NL + "{" + NL + "  if(Number >= USBCORE001_HOST_MAX_PIPE)" + NL + "  {" + NL + "    return false;" + NL + "  }" + NL + "" + NL + "  USBCORE001_HostPipe[Number].dev_addr = USB_HOST_DEVICEADDRESS;" + NL + "  USBCORE001_HostPipe[Number].ep_num = EndpointNumber & 0x0F;" + NL + "  USBCORE001_HostPipe[Number].pipe_type = Type;" + NL + "  USBCORE001_HostPipe[Number].pipe_dir = EndpointNumber & 0xF0;" + NL + "  USBCORE001_HostPipe[Number].mps = Size;" + NL + "" + NL + "  return(true);" + NL + "}" + NL + "" + NL + "" + NL + "/* This function will prepare the USB request and will queue it to the" + NL + " * Synopsys driver." + NL + " * This is the LUFA compatible API." + NL + " */" + NL + "uint8_t Pipe_Write_Stream_LE(const void* Buffer," + NL + "                             uint16_t Length," + NL + "                             uint16_t* const BytesProcessed)" + NL + "{" + NL + "  uint8_t Status;" + NL + "" + NL + "  if(USBCORE001_HostPipe[USBCORE001_HostHCD.CurPipeNum].pipe_type" + NL + "                                                          == EP_TYPE_INTERRUPT)" + NL + "  {" + NL + "    dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL, " + NL + "                              (void *)Buffer, (int)Buffer, Length, NULL," + NL + "                                0, 1, USBCORE001_HostInterruptInterval);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL," + NL + "                              (void *)Buffer, (int)Buffer, Length, NULL," + NL + "                               0, 1, 0);" + NL + "  }" + NL + "" + NL + "  USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum] = " + NL + "                    &USBCORE001_HostEndpointpIn[USBCORE001_HostHCD.CurPipeNum];" + NL + "  USBCORE001_HostURBFlag = 0;" + NL + "  if(dwc_otg_hcd_urb_enqueue(&USBCORE001_HostDwcOtgHcd, " + NL + "                             &USBCORE001_HostDwcOtgUrb, " + NL + "  &USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum]->HcPriv, 1) != 0 )" + NL + "  {" + NL + "    return  HOST_SENDCONTROL_DeviceDisconnected;    " + NL + "  }" + NL + "" + NL + "  while(USBCORE001_HostURBFlag == 0);" + NL + "" + NL + "  memset(&USBCORE001_HostDwcOtgUrb, 0, sizeof(USBCORE001_HostDwcOtgUrb));" + NL + "" + NL + "  if(Get_HostStat() == USBCORE001_HOST_STATE_WaitForDevice)" + NL + "  {" + NL + "    Status = HOST_SENDCONTROL_DeviceDisconnected;" + NL + "  }" + NL + "  else if(USBCORE001_HostURBFlag != 1)" + NL + "  {" + NL + "    Status = HOST_SENDCONTROL_PipeError;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    Status = PIPE_RWSTREAM_NoError;" + NL + "  }" + NL + "" + NL + "  return(Status);" + NL + "}" + NL + "" + NL + "/* This function will prepare the USB request and will queue it " + NL + " * to the synopsys driver. This is the LUFA compatible API." + NL + " */" + NL + "uint8_t Pipe_Read_Stream_LE(void* Buffer," + NL + "                            uint16_t Length," + NL + "                            uint16_t* const BytesProcessed)" + NL + "{" + NL + "  uint8_t Status;" + NL + "" + NL + "  if(USBCORE001_HostPipe[USBCORE001_HostHCD.CurPipeNum].pipe_type " + NL + "                                                          == EP_TYPE_INTERRUPT)" + NL + "  {" + NL + "    dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL, Buffer," + NL + "                               (int)Buffer, Length, NULL, 0, 1," + NL + "                                USBCORE001_HostInterruptInterval);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL, Buffer, " + NL + "                               (int)Buffer, Length, NULL, 0, 1, 0);" + NL + "  }" + NL + "" + NL + "  USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum] = " + NL + "                    &USBCORE001_HostEndpointpIn[USBCORE001_HostHCD.CurPipeNum];" + NL + "" + NL + "  USBCORE001_HostURBFlag = 0;" + NL + "  if(dwc_otg_hcd_urb_enqueue(&USBCORE001_HostDwcOtgHcd, " + NL + "                             &USBCORE001_HostDwcOtgUrb," + NL + "   &USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum]->HcPriv, 1) != 0)" + NL + "  {" + NL + "    return  HOST_SENDCONTROL_DeviceDisconnected;" + NL + "  }" + NL + "" + NL + "  while(USBCORE001_HostURBFlag == 0);" + NL + "" + NL + "  memset(&USBCORE001_HostDwcOtgUrb, 0, sizeof(USBCORE001_HostDwcOtgUrb));" + NL + "" + NL + "  if(Get_HostStat() == USBCORE001_HOST_STATE_WaitForDevice)" + NL + "  {" + NL + "    Status = HOST_SENDCONTROL_DeviceDisconnected;" + NL + "  }" + NL + "  else if(USBCORE001_HostURBFlag == 1)" + NL + "  {" + NL + "    Status = PIPE_RWSTREAM_NoError;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    Status = HOST_SENDCONTROL_PipeError;" + NL + "  }" + NL + "" + NL + "  return(Status);" + NL + "}" + NL + "" + NL + "/* This function will read one byte of data from device. " + NL + " * This is the LUFA compatible API." + NL + " */" + NL + "int16_t Pipe_Read_8(void)" + NL + "{" + NL + "  static uint32_t RxDataLen = 0;" + NL + "  static uint32_t Indx = 0;" + NL + "  int16_t RxDataByte;" + NL + "" + NL + "  if(RxDataLen < 1)" + NL + "  {" + NL + "    Indx = 0;" + NL + "    RxDataLen = 0;" + NL + "    memset(USBCORE001_DataBuffer, 0, 64 * sizeof(uint8_t));" + NL + "    if(USBCORE001_HostPipe[USBCORE001_HostHCD.CurPipeNum].pipe_type" + NL + "                              == EP_TYPE_INTERRUPT)" + NL + "    {" + NL + "      dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL, (int *)&USBCORE001_DataBuffer," + NL + "                    (int)NULL, USBCORE001_HOST_ONE_BYTE, NULL, 0, 1," + NL + "                    USBCORE001_HostInterruptInterval);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL, (int *)&USBCORE001_DataBuffer," + NL + "                    (int)NULL, USBCORE001_HOST_ONE_BYTE," + NL + "                    NULL, 0, 1, 0);" + NL + "    }" + NL + "" + NL + "    USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum] =" + NL + "             &USBCORE001_HostEndpointpIn[USBCORE001_HostHCD.CurPipeNum];" + NL + "" + NL + "    USBCORE001_HostURBFlag = 0;" + NL + "    if(dwc_otg_hcd_urb_enqueue(&USBCORE001_HostDwcOtgHcd," + NL + "                              &USBCORE001_HostDwcOtgUrb," + NL + "     &USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum]->HcPriv, 1) != 0)" + NL + "    {" + NL + "      return  HOST_SENDCONTROL_DeviceDisconnected;" + NL + "    }" + NL + "" + NL + "    while(USBCORE001_HostURBFlag == 0);" + NL + "    RxDataLen = USBCORE001_HostDwcOtgUrb.actual_length;" + NL + "    memset(&USBCORE001_HostDwcOtgUrb, 0, sizeof(USBCORE001_HostDwcOtgUrb));" + NL + "" + NL + "    if(RxDataLen != 0)" + NL + "    {" + NL + "      RxDataByte = USBCORE001_DataBuffer[Indx];" + NL + "      RxDataLen--;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      RxDataByte = -1;" + NL + "    }" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    RxDataLen--;" + NL + "    Indx++;" + NL + "    RxDataByte = USBCORE001_DataBuffer[Indx];" + NL + "  }" + NL + "" + NL + "  return RxDataByte;" + NL + "}" + NL + "" + NL + "" + NL + "/* This function will prepare the USB request and will queue it" + NL + " * to the synopsys driver. This is the LUFA compatible API." + NL + " */" + NL + "void Pipe_Write_8(uint8_t Data)" + NL + "{" + NL + "  if(USBCORE001_HostPipe[USBCORE001_HostHCD.CurPipeNum].pipe_type " + NL + "                                                       == EP_TYPE_INTERRUPT)" + NL + "  {" + NL + "    dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL, &Data, " + NL + "                              (int)NULL, USBCORE001_HOST_ONE_BYTE, NULL, 0, 1," + NL + "                              USBCORE001_HostInterruptInterval);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    dwc_otg_hcd_urb_set_params(&USBCORE001_HostDwcOtgUrb, NULL, &Data," + NL + "                               (int)NULL, USBCORE001_HOST_ONE_BYTE, NULL," + NL + "                               0, 1, 0);" + NL + "  }              " + NL + "" + NL + "  USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum] = " + NL + "                     &USBCORE001_HostEndpointpIn[USBCORE001_HostHCD.CurPipeNum];" + NL + "" + NL + "  USBCORE001_HostURBFlag = 0;" + NL + "  if(dwc_otg_hcd_urb_enqueue(&USBCORE001_HostDwcOtgHcd," + NL + "                             &USBCORE001_HostDwcOtgUrb," + NL + "  &USBCORE001_HostHCD.EndPoint[USBCORE001_HostHCD.CurPipeNum]->HcPriv, 1) != 0);  " + NL + "  {" + NL + "    //return  HOST_SENDCONTROL_DeviceDisconnected;" + NL + "  }" + NL + "" + NL + "  while(USBCORE001_HostURBFlag == 0);" + NL + "" + NL + "  memset(&USBCORE001_HostDwcOtgUrb, 0, sizeof(USBCORE001_HostDwcOtgUrb));" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "void Pipe_Unfreeze(void)" + NL + "{" + NL + "" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "void Pipe_Freeze(void)" + NL + "{" + NL + "" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "void Pipe_ClearIN(void)" + NL + "{" + NL + "" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "void Pipe_ClearOUT(void)" + NL + "{" + NL + "" + NL + "}" + NL + "" + NL + "" + NL + "/* This function sets the periodicity of interrupt transfer.*/" + NL + "void Pipe_SetInterruptPeriod(const uint8_t Milliseconds)" + NL + "{" + NL + "  USBCORE001_HostInterruptInterval = Milliseconds;" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)" + NL + "{" + NL + "  return 0;  " + NL + "}" + NL + " " + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "uint16_t Pipe_BytesInPipe(void)" + NL + "{" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "bool Pipe_IsINReceived(void)" + NL + "{" + NL + "  return 1;" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "uint8_t Pipe_WaitUntilReady(void)" + NL + "{" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "uint16_t USB_Host_GetFrameNumber(void)" + NL + "{" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "bool Pipe_IsStalled(void)" + NL + "{" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "bool Pipe_IsOUTReady(void)" + NL + "{" + NL + "  return 1;" + NL + "}" + NL + "" + NL + "/* Dummy function to make it compatible with LUFA stack.*/" + NL + "bool Pipe_IsReadWriteAllowed(void)" + NL + "{" + NL + "  return 1;" + NL + "}" + NL + "" + NL + "/* This function swaps data endianness.*/" + NL + "void SwapEndian_n(void* const Data, uint8_t Length)" + NL + "{" + NL + "  uint8_t* CurrDataPos = (uint8_t*)Data;" + NL + "" + NL + "  while (Length > 1)" + NL + "  {" + NL + "    uint8_t Temp = *CurrDataPos;" + NL + "    *CurrDataPos = *(CurrDataPos + Length - 1);" + NL + "    *(CurrDataPos + Length - 1) = Temp;" + NL + "" + NL + "    CurrDataPos++;" + NL + "    Length -= 2;" + NL + "  }" + NL + "}" + NL + "#endif /* DWC_DEVICE_ONLY */" + NL + "" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_5 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/usbcore001/";
     int appInst = 0;
   int HostChannel_Size = 0;

    stringBuffer.append(TEXT_2);
    
HostChannel_Size = app.getIntegerValue(AppBaseuri + appInst +"/USBCORE001_irwhost_channel_sz/");

    stringBuffer.append(TEXT_3);
    stringBuffer.append(HostChannel_Size);
    stringBuffer.append(TEXT_4);
    stringBuffer.append(TEXT_5);
    return stringBuffer.toString();
  }
}
